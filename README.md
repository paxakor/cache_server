# Caching web server
Задача: написать кэширующий веб-сервер, способный либо перенаправлять запросы на другие ресурсы, либо выдавать кэшированный ответ по протоколу HTTP.
Подобные программы позволяют снизить нагрузку на сеть и среднюю длительность задержки между запросом и ответом на стороне клиента. Они выступают посредниками между клиентами и некоторой частью глобальной сети (прокси-сервера). Эффективность достигается за счёт сохранения локальных копий документов на кэширующем сервере, что позволяет не обращаться к внешним глобальным хранилищам, а выдавать статический ответ мгновенно.

## Существующее ПО, решающее схожие задачи.
* Apache HTTP Server -- веб-сервер, ориентированный на надёжность и гибкость конфигурации. По статистике Netcraft, лидирует по количеству обслуживаемых хостов.
* nginx -- многофункциональный веб-сервер. Так же находится в числе лидеров рейтингов Netcraft.
* Squid -- распространяемый под лицензией GNU GPL кэширующий прокси-сервер.
* Varnish -- HTTP акселератор -- проски-сервер, уменьшающий задержку доступа к веб-сайтам, благодаря кэшированию.
* HandyCache -- локальный кэширующий прокси-сервер для Windows.
* Технология BranchCache в Windows.

## Архитектура проекта
Сервер должен понимать основные HTTP запросы (GET, HEAD, etc.) и корректно отвечать на них, используя механизм кэширования.
#### Основной поток
После создания объекта сервера в функции `main` основной поток запускает `max_threads` потоков-помощников. Основной поток использует epoll (механизм ядра Linux) для получения событий и передаёт события помощникам. Для синхронизации доступа к коллекциям клиентов между основным потоком и помощниками используются мьютексы и условные переменные.
#### Помощники
Вспомогательные потоки ожидают поступления новых запросов или сигнала о прекращении работы сервера. При установлении нового соединения помощник считывает данные с сокета клиента и выдаёт в ответ статический файл или сообщение об ошибке.
#### Логирование
Логер умеет писать уведомления и ошибки, ронять сервер при фатальных ошибках и выводить интересные сведения на печать. Сообщения сохраняются в один файл подряд. Доступ к записи во внутренний кэш логера синхронизирован с помощью мьютекса.
#### Сигналы
Сервер переходит в остановленное состояние после получения сигнала `SIGINT` или `SIGTERM`. В этом состоянии корректно завершаются активные соединения и заканчивают работу помощники. Пока что не реализовано прерывание ожидающего системного вызова epoll_wait, так что сервер выключается только после очередной (неудачной) попытки подключения.
#### Тесты
Реализован бедный набор тестов.
* tests/ut/utils_ut.py -- тест проверяющий корректность библиотеки utils, предназначенной для работы со строками.
* tests/insatiable_client.cpp -- тест, имитирующий несколько клиентов, многократно запращивающих файл /index.html

### Реализованный функционал
* Обработка GET-запросов и выдача статической страницы.
* Многопоточная обработка запросов.
* Получение событий с помощью механизма epoll.
* Логирование

### Будущий функционал
* Получение событий с помощью механизма kqueue.
* Перенаправление запросов.
* Кэширование ответов на запросы.
* Запуск через systemd

### Сборка
Для сборки проекта (с тестами) выполните команду в корневой дирректории репозитория:<br />
`mkdir build && cd build && cmake ../code/ && make`

Проект использует библотеку для работы с файловой системой. Если компилятор не поддерживает std::filesystem, которая вошла в стандарт C++17 и уже давно существует как std::experimental::filesystem, то есть возможность использовать boost.filesystem. Для этого добавьте к cmake флаг<br />
`-DUSE_BOOST_FILESYSTEM:BOOL=ON`

### Формат конфигурационного файла
config.txt должен содержать одну запись на одну строку следующего вида:<br />
`opt val`<br />
где opt -- название опции сервера, а val -- её значение. Допускается пропуск некоторых параметров (будут использованы стандартные значения). Список опций:
* dir -- корневая директория сервера.
* port -- номер порта для коммуникаций с миром.
* max_threads -- количество потоков-помощников (максимальное количество -- max_threads + 2).

### Запуск и использование
Перед началом работы нужно убедиться, что конфигурационный файл корректен. Достаточно запустить бинарный файл `server`, полученный после компиляции проекта. После этого можно будет использовать localhost:port как ~~прокси-сервер для веб-соединений~~ веб-сервер для просмотра статических страниц.

### Автор
Корозевцев Павел<br />
email: paxakor@yandex.ru<br />
[github](https://github.com/paxakor)<br />
[telegram](https://telegram.me/paxakor)<br />
[vkontakte](https://vk.com/paxakor)
